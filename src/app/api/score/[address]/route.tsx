/**
 * --------------------------------------------------------------------
 * RISK SCORING
 * --------------------------------------------------------------------
 *
 * TOP-LEVEL SHAPE
 * ┌───────────────────────────────────────────────────────────────┐
 * │ token            { name, symbol, address }                  │
 * │ holdersAnalysed  number  – wallets that had enough history  │
 * │ tokenSummary     { …see below… }                            │
 * │ holders[]        array<PerHolder> – one row per whale       │
 * └───────────────────────────────────────────────────────────────┘
 *
 * ──────────────────────────────────────────────────────────────────
 * tokenSummary  – explains the health of the pool
 * ──────────────────────────────────────────────────────────────────
 * probDump1h : 0‥1
 *     Probability that **≥5 %** of pool depth will be market-sold
 *     by the analysed wallets within the *next* hour.
 *
 * sharkShare : 0‥1
 *     Share of analysed exposure held by wallets whose
 *     historical **Profit Factor ≥ 1.5** (aka “consistent winners”).
 *     More sharks → exits are colder and more coordinated.
 *
 * richness : number (cashUSD ÷ positionUSD), median across holders
 *     < 0.3  → cash-poor; may sell just to raise dry powder  
 *     0.3-1  → balanced; can add *or* exit opportunistically  
 *     > 1    → well-funded; not forced to dump
 *
 * ──────────────────────────────────────────────────────────────────
 * holders[] – per-wallet live snapshot
 * ──────────────────────────────────────────────────────────────────
 * address       full pubkey  
 * short         abbreviated pubkey (use this in prose)  
 * exposurePct   share of total supply (%)  
 * sellScore     0-1 overall exit pressure (see below)  
 * label         enum generated by the new logic  
 *               • Diamond hands  
 *               • Likely holder  
 *               • Averaging-down zone / Scale-out zone  
 *               • Profit-taking likely / Capitulation risk  
 *               • Exit-liquidity hunter / Forced seller  
 * sizeX         USD originally spent on this token  
 * tProfitUSD    realised + unrealised $ profit (neg = loss)  
 * uPnlX         current unrealised ROI (decimal)  
 * rPnlX         realised ROI already banked  
 * holdHours     hours since first buy of the token  
 * cashUSD       SOL + stable balance still idle  
 * basePF        Profit-Factor on other coins (<1 loser, ≥1.5 shark, null fresh)  
 * isFresh       true if wallet has <3 historical tokens
 * ------------------------
 * sellScore formula (v0.2)
 * ------------------------
 * profitTaking = sigmoid(tProfitUSD/sizeX − 0.30)   if tProfitUSD > 0  
 * capitulation = sigmoid(−tProfitUSD/sizeX − 0.10)  if tProfitUSD < 0  
 * overTime     = sigmoid(holdHours / μ_hold − 1)  
 * oversize     = sigmoid(sizeX / μ_size − 1)
 * 
 * score = 0.4·(profitTaking + capitulation)  
 *       + 0.3·overTime  
 *       + 0.3·oversize  
 *
 **/

import { NextResponse } from 'next/server';
import { getTopTokenHolders } from '@/lib/token';
import { getWalletBalance } from '@/lib/wallet-balance';
// import { getWalletPnl } from '@/lib/wallet-pnl';
import { calculateWalletMetrics, getPnL } from '@/lib/wallet-metrics';
import { computeSellScore, sellLabel, sigmoid } from '@/lib/sell-score';
import { abbreviateAddress } from '@/lib/formatting';
import type { IHoldingsDetailed, IWalletMetrics } from '@/types/wallet';
import { Big } from 'big.js';

const KB_IP = process.env.CHERRY_KB;

export async function GET(
  _req: Request,
  { params }: { params: { address: string } }
) {
  try {
    const tokenAddress = params.address;

    /* -------------------------------------------------- */
    /* 1) who are the whales?                             */
    /* -------------------------------------------------- */
    const { tokenName, tokenSymbol, topHolders, tokenSupply } = await getTopTokenHolders(tokenAddress);
    const slice = topHolders.slice(0, 30);

    /* -------------------------------------------------- */
    /* 2) crunch each holder in parallel                  */
    /* -------------------------------------------------- */
    const perHolder = await Promise.all(
      slice.map(async (h) => {
        try {
          /* ---------- a. raw wallet data ---------- */
          const pnlRaw   = await getPnL(h.address.address);
          const holdings = pnlRaw as IHoldingsDetailed[];

          /* detect “fresh” wallet ( <3 distinct tokens ) */
          const uniqueTokens = new Set(holdings.map((o) => o.token.address));
          const isFresh = uniqueTokens.size < 3;

          /* ---------- b. split X-token vs rest ---------- */
          const xRecord  = holdings.find((o) => o.token.address === tokenAddress);
          const baseHold = holdings.filter((o) => o.token.address !== tokenAddress);

          if (!xRecord || !baseHold.length) return null; // no baseline → skip (newbie or bot)

          /* ---------- c. baseline metrics ---------- */
          const baseMetrics: IWalletMetrics = calculateWalletMetrics(baseHold);

          /* ---------- d. wallet cash ---------- */
          const balance  = await getWalletBalance(h.address.address);
          const cashUSD  = balance.solUSD + balance.stablesUSD;

          /* ---------- e. live X position facts ---------- */
          const sizeX      = parseFloat(xRecord.history_bought_cost || '0');
          const uPnlX      = parseFloat(xRecord.unrealized_pnl || '0');
          const rPnlX      = parseFloat(xRecord.realized_pnl || '0');      
          const start      = xRecord.start_holding_at ?? Math.floor(Date.now()/1000);
          const holdX      = (Date.now()/1000 - start) / 3600; // h
          const muSize     = baseMetrics.avgPositionSizeUSD || 1; // avoid /0
          const muHold     = baseMetrics.avgHoldTimeHours   || 1;
          const tProfitUSD = parseFloat(xRecord.unrealized_profit || '0') + parseFloat(xRecord.realized_profit || '0');

          /* dollar-based ROI for greed term */
          const pnlDollarRatio = sizeX > 0 ? tProfitUSD / sizeX : 0; // protect /0

          /* ---------- f. sell score ---------- */
          // guard against divide-by-zero beforehand
          const sizeRatio  = muSize > 0 ? sizeX / muSize : Infinity;
          const holdRatio  = muHold > 0 ? holdX / muHold : 1;
          const cashRatio  = sizeX > 0 ? cashUSD / sizeX   : Infinity;

          const sellScore = computeSellScore(
            sizeRatio,
            holdRatio,
            pnlDollarRatio,
            cashRatio
          );

          const label = sellLabel(sellScore, pnlDollarRatio, cashRatio, sizeRatio);

          return {
            address: h.address.address,
            short: abbreviateAddress(h.address.address),
            exposurePct: ((h.balance / (tokenSupply ?? 1)) * 100),
            sellScore,
            label,
            sizeX,
            uPnlX,
            rPnlX,
            pnlDollarRatio,
            isFresh,
            holdHours: holdX,
            cashUSD,
            tProfitUSD,
            basePF: baseMetrics.profitFactor,
          };
        } catch (err) {
          console.error('holder fail', h.address, err);
          return null;
        }
      })
    ).then((arr) => arr.filter(Boolean) as NonNullable<typeof arr[number]>[]);

    if (!perHolder.length) {
      return NextResponse.json(
        { error: 'No comparable holders (all fresh wallets?)' },
        { status: 422 }
      );
    }

    /* -------------------------------------------------- */
    /* 3) token-level aggregates                          */
    /* -------------------------------------------------- */
    const totalSize = perHolder.reduce((s, d) => s + d.sizeX, 0);

    const probDump1h = perHolder.reduce((acc, d) => acc + d.sellScore * d.sizeX, 0) / (totalSize || 1);

    const sharkExposure = perHolder
      .filter((d) => d.basePF >= 1.5)
      .reduce((sum, d) => sum + d.sizeX, 0);

    const sharkShare = totalSize ? sharkExposure / totalSize : 0;

    const richnessArr = perHolder.map((d) => d.cashUSD / (d.sizeX || 1));
    richnessArr.sort((a, b) => a - b);
    const richness = richnessArr[Math.floor(richnessArr.length / 2)]; // median

    /* -------------------------------------------------- */
    /* 4) respond                                         */
    /* -------------------------------------------------- */
    const aiRes = await fetch(`${KB_IP}/getAiSummary`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
            solAddress: tokenAddress,
            riskSummary: {
              token:          { name: tokenName, symbol: tokenSymbol, address: tokenAddress },
              holdersAnalysed: perHolder.length,
              tokenSummary:    { probDump1h, sharkShare, richness },
              holders:         perHolder,
            },
          }),
      });
    console.log(aiRes);
    const { summary: aiSummary } = aiRes.ok ? await aiRes.json() : { summary: null };

    /* -------------------------------------------------- */
    /* 5) respond                                         */
    /* -------------------------------------------------- */
    return NextResponse.json({
      token: { name: tokenName, symbol: tokenSymbol, address: tokenAddress },
      holdersAnalysed: perHolder.length,
      tokenSummary: {
        probDump1h,   // 0-1
        sharkShare,   // 0-1
        richness,     // median cash / pos
      },
      aiSummary,
      holders: perHolder,
    });
  } catch (error) {
    console.error('Error in GET /address/[address]:', error);
    return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
  }
}